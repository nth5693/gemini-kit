/**
 * Orchestrator Engine
 * Coordinates agents, manages workflows, handles retries and parallel execution
 */
import { z } from 'zod';
import { startSession, getCurrentSession, addAgentResult, updateContext, incrementRetry, canRetry, endSession, getSessionSummary, listSessions, initTeamState, } from './team-state.js';
import { getWorkflow, listWorkflows, autoSelectWorkflow, getStepPrompt, } from './workflows.js';
// HIGH 2 FIX: Schema for validated workflow context
const WorkflowContextSchema = z.object({
    workflowType: z.string().optional(),
    currentStep: z.number().int().min(-1).default(0),
    task: z.string().optional(),
}).passthrough(); // Allow extra keys
// Safe getter for typed context values
function getTypedContext(context) {
    const result = WorkflowContextSchema.safeParse(context);
    if (result.success) {
        return result.data;
    }
    // Return safe defaults if parsing fails
    return { currentStep: 0 };
}
const DEFAULT_CONFIG = {
    maxRetries: 3,
    parallelEnabled: true,
    autoRetry: true,
    verbose: false,
};
let config = DEFAULT_CONFIG;
/**
 * Initialize orchestrator
 */
export function initOrchestrator(customConfig) {
    config = { ...DEFAULT_CONFIG, ...customConfig };
    initTeamState({ maxRetries: config.maxRetries });
}
/**
 * Start a new team session with a goal
 */
export function teamStart(goal, sessionName) {
    const session = startSession(goal, sessionName);
    const { workflow: suggested } = autoSelectWorkflow(goal);
    return {
        success: true,
        session,
        suggestedWorkflow: suggested.name,
        allWorkflows: listWorkflows(),
    };
}
/**
 * Get current session status
 */
export function teamStatus() {
    const session = getCurrentSession();
    return {
        hasSession: session !== null,
        summary: getSessionSummary(),
        session,
    };
}
/**
 * End current session
 */
export function teamEnd(status = 'completed') {
    const session = endSession(status);
    return {
        success: session !== null,
        summary: session ? getSessionSummary() : 'No active session to end',
        session,
    };
}
/**
 * Execute a single workflow step
 */
export function executeStep(step, task) {
    const startTime = Date.now();
    const context = getCurrentSession()?.context || {};
    // Generate prompt for this step
    const prompt = getStepPrompt(step, task, context);
    // Create result (actual execution would be done by Gemini CLI)
    const result = {
        agent: step.agent,
        status: 'pending',
        output: prompt,
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
    };
    // Add to session
    addAgentResult(result);
    return result;
}
/**
 * Run a complete workflow
 */
export function runWorkflow(workflowName, task) {
    const workflow = getWorkflow(workflowName);
    if (!workflow) {
        return {
            success: false,
            workflow: undefined,
            steps: [],
            currentStep: -1,
            message: `Workflow '${workflowName}' not found. Available: ${listWorkflows().map(w => w.name).join(', ')}`,
        };
    }
    // Ensure session exists
    let session = getCurrentSession();
    if (!session) {
        session = startSession(task, `${workflow.name} - ${task.slice(0, 50)}`);
    }
    // Update session with workflow info
    updateContext('workflowType', workflow.name);
    updateContext('task', task);
    updateContext('currentStep', 0);
    // DON'T pre-generate prompts - return step metadata only
    // Prompts will be generated just-in-time with current context
    const steps = workflow.steps.map(step => ({
        step,
        prompt: '', // Will be generated by kit_get_next_step
    }));
    return {
        success: true,
        workflow,
        steps,
        currentStep: 0,
        message: `Workflow '${workflow.name}' started with ${steps.length} steps:\n${steps.map((s, i) => `${i + 1}. ${s.step.agent}: ${s.step.description}`).join('\n')}\n\nUse kit_get_next_step to get the current step prompt.`,
    };
}
/**
 * Get the next step prompt with CURRENT context (just-in-time generation)
 * This ensures each step receives context from previous steps
 */
export function getNextStep() {
    const session = getCurrentSession();
    if (!session) {
        return {
            hasMore: false,
            stepIndex: -1,
            step: null,
            prompt: 'No active session. Start a workflow with kit_run_workflow first.',
            remainingSteps: 0,
            completed: false,
        };
    }
    const workflowName = session.context.workflowType;
    const task = session.context.task;
    const workflow = getWorkflow(workflowName);
    if (!workflow) {
        return {
            hasMore: false,
            stepIndex: -1,
            step: null,
            prompt: `Workflow '${workflowName}' not found.`,
            remainingSteps: 0,
            completed: false,
        };
    }
    // HIGH 2 FIX: Use validated typed context instead of unsafe cast
    const typedContext = getTypedContext(session.context);
    const currentStep = typedContext.currentStep;
    if (currentStep >= workflow.steps.length) {
        return {
            hasMore: false,
            stepIndex: currentStep,
            step: null,
            prompt: 'ðŸŽ‰ Workflow completed! All steps done.',
            remainingSteps: 0,
            completed: true,
        };
    }
    const step = workflow.steps[currentStep];
    // Generate prompt with CURRENT context (includes results from previous steps)
    const prompt = getStepPrompt(step, task, session.context);
    return {
        hasMore: currentStep < workflow.steps.length - 1,
        stepIndex: currentStep,
        step,
        prompt,
        remainingSteps: workflow.steps.length - currentStep - 1,
        completed: false,
    };
}
/**
 * Advance to next step after completing current step
 * Saves step result to context for next step to use
 */
export function advanceStep(stepResult) {
    const session = getCurrentSession();
    if (!session) {
        return {
            advanced: false,
            nextStepIndex: -1,
            message: 'No active session.'
        };
    }
    // HIGH 2 FIX: Use validated typed context
    const typedContext = getTypedContext(session.context);
    const currentStep = typedContext.currentStep;
    const workflowName = session.context.workflowType;
    const workflow = getWorkflow(workflowName);
    if (!workflow) {
        return {
            advanced: false,
            nextStepIndex: currentStep,
            message: 'Workflow not found.'
        };
    }
    if (currentStep >= workflow.steps.length) {
        return {
            advanced: false,
            nextStepIndex: currentStep,
            message: 'Workflow already completed.'
        };
    }
    const completedStep = workflow.steps[currentStep];
    // Save step result to context for next step
    updateContext(`step_${currentStep}_result`, stepResult);
    updateContext(`step_${currentStep}_agent`, completedStep.agent);
    updateContext('lastStepResult', stepResult);
    updateContext('lastAgent', completedStep.agent);
    // Add to agent results
    addAgentResult({
        agent: completedStep.agent,
        status: 'success',
        output: stepResult,
        timestamp: new Date().toISOString(),
        duration: 0,
    });
    // Advance to next step
    const nextStep = currentStep + 1;
    updateContext('currentStep', nextStep);
    const isComplete = nextStep >= workflow.steps.length;
    return {
        advanced: true,
        nextStepIndex: nextStep,
        message: isComplete
            ? 'ðŸŽ‰ All steps completed! Workflow finished.'
            : `âœ… Step ${currentStep + 1} completed. Ready for step ${nextStep + 1}.`,
    };
}
/**
 * Handle step failure with retry logic
 */
export function handleStepFailure(step, error) {
    const session = getCurrentSession();
    if (!session) {
        return {
            action: 'abort',
            canRetry: false,
            retryCount: 0,
            message: 'No active session',
        };
    }
    // Record failure
    addAgentResult({
        agent: step.agent,
        status: 'failure',
        output: error,
        timestamp: new Date().toISOString(),
    });
    const onFailure = step.onFailure || 'abort';
    if (onFailure === 'retry' && canRetry()) {
        const count = incrementRetry();
        return {
            action: 'retry',
            canRetry: true,
            retryCount: count,
            message: `Retrying ${step.agent} (attempt ${count}/${session.maxRetries})`,
        };
    }
    if (onFailure === 'fallback' && step.fallbackAgent) {
        return {
            action: 'fallback',
            canRetry: false,
            retryCount: session.retryCount,
            message: `Falling back to ${step.fallbackAgent}`,
        };
    }
    if (onFailure === 'skip' || !step.required) {
        return {
            action: 'skip',
            canRetry: false,
            retryCount: session.retryCount,
            message: `Skipping optional step: ${step.agent}`,
        };
    }
    return {
        action: 'abort',
        canRetry: false,
        retryCount: session.retryCount,
        message: `Aborting workflow: ${step.agent} failed`,
    };
}
/**
 * Smart routing: analyze task and return recommended workflow
 */
export function smartRoute(task) {
    // MEDIUM FIX: Use confidence from autoSelectWorkflow, no duplicate regex
    const { workflow, confidence } = autoSelectWorkflow(task);
    const allWorkflows = listWorkflows();
    return {
        workflow,
        confidence,
        reasoning: `Selected '${workflow.name}' workflow based on task analysis`,
        alternativeWorkflows: allWorkflows.filter(w => w.name !== workflow.name).map(w => w.name),
    };
}
/**
 * Get collaboration prompt for agent to consult another agent
 */
export function getCollaborationPrompt(fromAgent, toAgent, question, context) {
    return `
## Agent Collaboration Request

**From:** ${fromAgent}
**To:** ${toAgent}
**Question:** ${question}

### Context
${JSON.stringify(context, null, 2)}

Please provide your expert opinion on this matter.
`.trim();
}
/**
 * List past sessions
 */
export function getSessionHistory() {
    return listSessions();
}
